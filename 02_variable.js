/* 
 - 변수는 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이다.
 - 변수에 저장한 값은 다시 읽어서 재사용할 수 있다.
 - 변수에 값을 저장하는 것을 할당(대입, 저장)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조라 한다.
 - 변수 이름을 식별자라고도 하는데, 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
    - 변수, 함수, 클래스 등의 이름을 모두 식별자라고 한다.
    - 식별자는 네이밍 규칙을 준수해야하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.
 - 변수 선언이란 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다.
    - 변수 선언 키워드: var, let, const
 - 변수 이름을 비롯한 모든 식별자는 싫행 컨텍스트에 등록된다.
    - 실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.
*/

/* 
 - var 키워드 특징: 
    - 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원한다.
        for문이나 if문 블록 안에서 선언한 변수도 전역변수로 선언되는 부작용이 발생
    - 변수 선언을 하면 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.
        변수 선언 코드 전 변수를 참조할 수 있는 기이한 현상 발생...
        초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있고, 
        이를 쓰레기 값이라 한다. 이러한 위험을 관리하기 위해 var 키워드는 암묵적으로 undefined 값으로 변수를 초기화하는 것이다.
 
- 변수 호이스팅
    - 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
    - 변수 선언뿐 아니라, var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.
    - 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.
*/

console.log('변수 호이스팅 (undefined 값으로 암묵적 할당) >', i, j); // undefined undefined

j = 10; // 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다. (선언은 런타임 이전에 / 할당은 런타임에 실행)
console.log('j 값을 undefined에서 10으로 할당 ...', j)

for(var i = 0; i < 2; i++){ // i 변수 선언
    console.log('for문 안의 i >', i);
    console.log('전역변수가 되어버린 j >', j)
    for(var j = 2; j > 0; j--) { // j 변수 선언
        console.log('이중 for문 안의 j >', j);
    }
}

console.log('var로 i와 j를 선언했기 때문에 전역변수가 되어 for문 밖에서도 참조 가능 (부작용!!!) >', i, j);

// ---------------------------------------------------------------------------------------- //

console.log('score 값 >', score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log('score 값 >', score); // 80

/* 
 - 변수 호이스팅이 발생하기 때문에, var score; 선언문이 런타임 이전에 먼저 실행됨 
 - 따라서, 위의 예제에서 score 변수에 할당된 값의 순서는 undefined -> 80 이 되는 것이다.
*/

// ---------------------------------------------------------------------------------------- //

/* 
 - 재할당은 기존의 메모리 공간을 지우고 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장한다.
 - 재할당 된 변수는 새로운 메모리 공간의 주소를 가리킨다.

    변수: 값을 재할당 할 수 있음 (var, let)
    상수: 값을 재할당 할 수 없음 (const)
*/

/* var, let, const로 변수 선언 */
var city = 'Seoul';
let name = 'Heeney';
const age = 20;

/* 값 재할당 시도 */
city = 'Busan';
name = 'Honey';
// age = 25; // 상수에 재할당을 시도했기 때문에 에러 발생

console.log('city >', city); // Busan
console.log('name >', name); // Honey

const user = {
    name: 'Heeney',
    age: 20
}

// ---------------------------------------------------------------------------------------- //

/* 
 - 식별자 네이밍 규칙 
    - 특수문자를 제외한 문자, 숫자, 언더바(_), 달러 기호($) 사용 가능
    - 숫자로 시작할 수 없다.
    - 예약어를 사용할 수 없다.
    - 대소문자를 구별한다. (같은 스펠링이더라도 대소문자가 다르면 별개의 변수로 인식한다)

 - 네이밍 컨벤션
    - 카멜 케이스 firstName
    - 스네이크 케이스 first_name
    - 파스칼 케이스 FirstName
    - 헝가리언 케이스
        - setFirstName // type + identifier
        - $elem = document.getElementById('myId') // DOM 노드
        - observable$ = fromEvent(document, 'click) // RxJS 옵저버블
*/